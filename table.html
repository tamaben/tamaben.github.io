<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Ultimate Gyro Ping Pong</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Helvetica Neue', sans-serif; user-select: none; color: white; }
        
        /* ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒ‰ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }
        #scoreboard {
            position: absolute; top: 20px; width: 100%; display: flex; justify-content: center; gap: 60px;
            text-shadow: 2px 2px 4px #000;
        }
        .score-box { text-align: center; }
        .score-num { font-size: 5rem; font-weight: 800; line-height: 1; }
        .p-label { font-size: 1.2rem; font-weight: bold; display: block; margin-bottom: 5px; }
        
        /* ã‚¬ã‚¤ãƒ‰è¡¨ç¤º */
        #guide-overlay {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            font-size: 1.5rem; color: #ffeb3b; text-shadow: 1px 1px 2px #000;
            opacity: 0.8;
        }

        /* æ¥ç¶šç”»é¢ */
        #setup-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
        }
        .setup-content { text-align: center; max-width: 600px; }
        h1 { font-size: 3rem; margin-bottom: 10px; color: #fff; text-shadow: 0 0 20px #00c3e3; }
        
        .control-card {
            background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; margin: 20px 0;
            border: 1px solid #555; display: flex; justify-content: space-around;
        }
        .c-item { width: 30%; }
        .icon { font-size: 3rem; display: block; margin-bottom: 10px; }
        
        .btn {
            background: linear-gradient(135deg, #00c3e3, #0056b3);
            color: white; padding: 15px 50px; font-size: 1.5rem; font-weight: bold;
            border: none; border-radius: 50px; cursor: pointer; margin-top: 20px;
            box-shadow: 0 0 15px rgba(0, 195, 227, 0.5); transition: transform 0.1s;
        }
        .btn:hover { transform: scale(1.05); }

        #msg-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 6rem; font-weight: 900; color: #fff;
            text-shadow: 0 0 30px rgba(255,255,255,0.8);
            display: none;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="scoreboard">
            <div class="score-box">
                <span class="p-label" style="color:#00c3e3">PLAYER 1</span>
                <div id="s-p1" class="score-num">0</div>
            </div>
            <div class="score-box">
                <span class="p-label" style="color:#ff5252">PLAYER 2</span>
                <div id="s-p2" class="score-num">0</div>
            </div>
        </div>
        <div id="msg-overlay">START</div>
        <div id="guide-overlay">ä½“ã‚’å·¦å³ã«å‚¾ã‘ã¦ç§»å‹•ï¼æ‰‹é¦–ã§è§’åº¦èª¿æ•´ï¼</div>
    </div>

    <div id="setup-screen">
        <div class="setup-content">
            <h1>ULTIMATE GYRO PING PONG</h1>
            <p>ã‚¹ãƒ†ã‚£ãƒƒã‚¯ä¸è¦ã€‚å…¨èº«ã§æ“ä½œã™ã‚‹æ¬¡ä¸–ä»£å“çƒã€‚</p>
            
            <div class="control-card">
                <div class="c-item">
                    <span class="icon">ğŸ¦µ</span>
                    <h3>ç§»å‹• (Move)</h3>
                    <p>ä½“ã‚’å·¦å³ã«å‚¾ã‘ã‚‹<br>(ã‚µã‚¤ãƒ‰ã‚¹ãƒ†ãƒƒãƒ—)</p>
                </div>
                <div class="c-item">
                    <span class="icon">â†ªï¸</span>
                    <h3>å›è»¢ (Spin)</h3>
                    <p>æ‰‹é¦–ã‚’ã²ã­ã‚‹<br>(è¢«ã›ã‚‹/ä»°ã)</p>
                </div>
                <div class="c-item">
                    <span class="icon">ğŸ‘‹</span>
                    <h3>æ‰“ã¤ (Hit)</h3>
                    <p>Joy-Conã‚’æŒ¯ã‚‹</p>
                </div>
            </div>

            <button class="btn" id="connect-btn">Joy-Conã‚’æ¥ç¶š (L -> R)</button>
            <p style="color:#aaa; font-size:0.9rem; margin-top:15px;">â€»PCã®Chromeã§Bluetoothæ¥ç¶šã—ã¦ãã ã•ã„</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- è¨­å®š ---
        const TABLE_W = 15.25, TABLE_L = 27.4, TABLE_H = 7.6, NET_H = 1.525;
        // ä½“ã®å‚¾ãã«å¯¾ã™ã‚‹ç§»å‹•æ„Ÿåº¦
        const MOVE_SENSITIVITY = 0.8; 
        
        let scene, camera, renderer;
        let ball, table;
        let players = [];
        let isPlaying = false;
        
        // ç‰©ç†
        let ballState = { pos: new THREE.Vector3(0,10,0), vel: new THREE.Vector3(0,0,0), spin: new THREE.Vector3(0,0,0), active: false };
        let scores = [0, 0];
        let server = 1;

        // éŸ³å£°
        const actx = new (window.AudioContext||window.webkitAudioContext)();

        // --- Joy-Con Logic (å®Œå…¨ã‚¸ãƒ£ã‚¤ãƒ­) ---
        class GyroController {
            constructor(device, id) {
                this.device = device;
                this.id = id;
                this.color = id===1 ? 0x00c3e3 : 0xff5252;
                
                // çŠ¶æ…‹
                this.tiltX = 0; // å·¦å³ã®å‚¾ã (ç§»å‹•ç”¨: Roll)
                this.tiltY = 0; // å‰å¾Œã®å‚¾ã (ãƒ©ã‚±ãƒƒãƒˆè§’åº¦ç”¨: Pitch)
                
                this.swing = 0;
                this.isSwinging = false;
                
                // ã‚¼ãƒ­ç‚¹è£œæ­£ç”¨
                this.centerTilt = 0;
                this.calibrated = false;
            }

            async init() {
                await this.device.open();
                await this.send(0x01, [0x00, 0x01, 0x40, 0x40, 0x00, 0x01, 0x40, 0x40]); // Rumble
                await this.send(0x01, [0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]); // Subcmd setup
                await this.sub(0x40, [0x01]); // IMU On
                await this.sub(0x03, [0x30]); // Standard Mode
                this.device.addEventListener('inputreport', this.handle.bind(this));
            }

            async send(cmd, d) { if(this.device.opened) await this.device.sendReport(cmd, new Uint8Array([cmd,...d])); }
            async sub(c, d) { await this.send(0x01, [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,c,...d]); }
            
            async rumble() {
                await this.send(0x10, [0x00,0x01,0x40,0x40,0x00,0x01,0x40,0x40]); 
                setTimeout(()=>this.send(0x10,[0,0,0,0,0,0,0,0]), 100);
            }

            handle(e) {
                const dt = new DataView(e.data.buffer);
                if(e.reportId!==0x30 && e.reportId!==0x21) return;

                // åŠ é€Ÿåº¦ (Gravity vector) ã‚’ä½¿ã£ã¦ã€Œçµ¶å¯¾çš„ãªå‚¾ãã€ã‚’æ¤œå‡º
                // ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¸ãƒ£ã‚¤ãƒ­ã®ãƒ‰ãƒªãƒ•ãƒˆï¼ˆã‚ºãƒ¬ï¼‰ã‚’é˜²ãã€
                // ã€Œä½“ãŒå³ã«å‚¾ã„ã¦ã„ã‚‹ï¼å³ç§»å‹•ã€ã¨ã„ã†ç›´æ„Ÿæ“ä½œã‚’å®Ÿç¾ã™ã‚‹
                
                const ax = dt.getInt16(13, true) * 0.000244;
                const ay = dt.getInt16(15, true) * 0.000244;
                const az = dt.getInt16(17, true) * 0.000244;

                // P1(L)ã¨P2(R)ã§åº§æ¨™ç³»ãŒé•ã†ãŸã‚èª¿æ•´
                // åŸºæœ¬çš„ã«Joy-Conã®å¹³ã‚‰ãªé¢ã‚’ä¸Šã«ã—ã¦æ°´å¹³ï¼0ã¨ã™ã‚‹
                // Roll (å·¦å³ã®å‚¾ã) -> ç§»å‹•
                // Pitch (å‰å¾Œã®å‚¾ã) -> ãƒ©ã‚±ãƒƒãƒˆè§’åº¦

                // ç°¡æ˜“è¨ˆç®— (Joy-Conã®æŒã¡æ–¹ã€Œã„ã„ã­æŒã¡ã€æƒ³å®š)
                // Yè»¸ãŒé•·æ‰‹æ–¹å‘ã€‚Zè»¸ãŒãƒœã‚¿ãƒ³é¢å‚ç›´ã€‚
                // å·¦å³ã«æŒ¯ã‚‹(Roll) -> Zè»¸é‡åŠ›æˆåˆ†å¤‰åŒ–
                // å‰å¾Œã«å›ã™(Pitch) -> Xè»¸é‡åŠ›æˆåˆ†å¤‰åŒ–
                
                let roll = -az; // å·¦å³
                let pitch = -ax; // æ‰‹é¦–ã®ã²ã­ã‚Š
                
                // Rã‚³ãƒ³ã¯åè»¢
                if (this.device.productId === 0x2007) {
                    roll *= -1;
                    pitch *= -1;
                }

                // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (åˆå›ã®ã¿ã€ç¾åœ¨ã®æŒã¡æ–¹ã‚’ã‚»ãƒ³ã‚¿ãƒ¼ã¨ã™ã‚‹)
                if (!this.calibrated) {
                    this.centerTilt = roll;
                    this.calibrated = true;
                }

                // å…¥åŠ›å€¤ã®å¹³æ»‘åŒ– (ã‚¸ãƒƒã‚¿ãƒ¼é™¤å»)
                const alpha = 0.1;
                this.tiltX = this.tiltX * (1-alpha) + (roll - this.centerTilt) * alpha;
                this.tiltY = this.tiltY * (1-alpha) + pitch * alpha;

                // ã‚¹ã‚¤ãƒ³ã‚°æ¤œçŸ¥ (åˆæˆåŠ é€Ÿåº¦ã®å¤‰åŒ–)
                const mag = Math.sqrt(ax*ax + ay*ay + az*az);
                if (mag > 2.2) {
                    this.isSwinging = true;
                    this.swing = mag;
                    setTimeout(()=>this.isSwinging=false, 250);
                }
            }
        }

        // --- 3D Scene ---
        function initGame() {
            scene = new THREE.Scene();
            // ã‚«ãƒ¡ãƒ©ä½ç½®: è¦³å®¢å¸­è¦–ç‚¹
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 200);
            camera.position.set(-25, 20, 0); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // ç’°å¢ƒ
            scene.add(new THREE.AmbientLight(0x404040));
            const spot = new THREE.SpotLight(0xffffff, 1.2);
            spot.position.set(0, 40, 0);
            spot.castShadow = true;
            scene.add(spot);

            // å“çƒå°
            const tMat = new THREE.MeshPhongMaterial({ color: 0x1e88e5, specular: 0x111111, shininess: 10 });
            table = new THREE.Mesh(new THREE.BoxGeometry(TABLE_W, 0.5, TABLE_L), tMat);
            table.position.y = TABLE_H;
            table.receiveShadow = true;
            scene.add(table);
            
            // ãƒãƒƒãƒˆ
            const net = new THREE.Mesh(
                new THREE.PlaneGeometry(TABLE_W+2, NET_H), 
                new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent:true, opacity:0.8 })
            );
            net.position.y = TABLE_H + NET_H/2;
            scene.add(net);

            // ãƒœãƒ¼ãƒ«
            ball = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffa726 }));
            ball.castShadow = true;
            scene.add(ball);

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ©ã‚±ãƒƒãƒˆ
            createPlayer(1);
            createPlayer(2);

            resetBall();
            animate();
        }

        function createPlayer(id) {
            const grp = new THREE.Group();
            
            // ãƒ©ã‚±ãƒƒãƒˆãƒ¢ãƒ‡ãƒ« (ç°¡æ˜“)
            const rMat = new THREE.MeshStandardMaterial({ color: id===1?0xd32f2f:0x212121 });
            const face = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.1, 32), rMat);
            face.rotation.x = Math.PI/2;
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.5, 0.3), new THREE.MeshStandardMaterial({color:0x8d6e63}));
            handle.position.y = -1.2;
            grp.add(face, handle);
            
            // å½±ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¶³ä½ç½®ç›®å®‰ï¼‰
            const shadow = new THREE.Mesh(new THREE.CircleGeometry(1.5, 32), new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.3}));
            shadow.rotation.x = -Math.PI/2;
            shadow.position.y = -TABLE_H + 0.1; // åœ°é¢
            grp.add(shadow);

            grp.position.set(0, TABLE_H+2, id===1 ? 20 : -20);
            scene.add(grp);
            players.push({ id, mesh: grp, x: 0 });
        }

        // --- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— ---
        function update(dt) {
            // 1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹• (å®Œå…¨ã‚¸ãƒ£ã‚¤ãƒ­: å‚¾ã -> ä½ç½®)
            players.forEach((p, i) => {
                const ctrl = (i===0) ? p1Ctrl : p2Ctrl;
                if(!ctrl) return;
                
                // TiltX (-1.0 ~ 1.0) ã‚’ä½ç½® (-8.0 ~ 8.0) ã«ãƒãƒƒãƒ”ãƒ³ã‚°
                // å®Ÿéš›ã«ä½“ã‚’å‚¾ã‘ã‚‹ã¨Joy-ConãŒå‚¾ã -> ãã‚Œã‚’ä½ç½®ã«ã™ã‚‹
                // è£œé–“ã‚’ã—ã¦æ»‘ã‚‰ã‹ã«å‹•ã‹ã™
                const targetX = ctrl.tiltX * 15.0; 
                p.x += (targetX - p.x) * 0.1; // Smooth damp
                
                // ç¯„å›²åˆ¶é™
                p.x = Math.max(-10, Math.min(10, p.x));
                
                // ä½ç½®é©ç”¨ (P2ã¯é€†å´)
                p.mesh.position.x = (p.id===1) ? p.x : -p.x;
                
                // ãƒ©ã‚±ãƒƒãƒˆè§’åº¦ (Pitch -> Rotation X)
                // æ‰‹é¦–ã®ã²ã­ã‚Šã‚’åæ˜ 
                const angle = ctrl.tiltY * 1.5;
                p.mesh.rotation.x = (p.id===1) ? angle : -angle;
                
                // ã‚¹ã‚¤ãƒ³ã‚°æ™‚ã®ãƒ©ã‚±ãƒƒãƒˆæ¼”å‡º
                if(ctrl.isSwinging) {
                    p.mesh.position.z += (p.id===1?-1:1) * 0.5; // å°‘ã—å‰ã«å‡ºã‚‹
                } else {
                    const baseZ = p.id===1 ? 20 : -20;
                    p.mesh.position.z += (baseZ - p.mesh.position.z) * 0.2; // æˆ»ã‚‹
                }
            });

            // 2. ãƒœãƒ¼ãƒ«ç‰©ç†
            if(!ballState.active && (p1Ctrl?.isSwinging || p2Ctrl?.isSwinging)) {
                // ã‚µãƒ¼ãƒ–åˆ¤å®š
                checkHit(server===1?players[0]:players[1], server===1?p1Ctrl:p2Ctrl, true);
            }

            if(ballState.active) {
                // é‡åŠ› & ç©ºæ°—æŠµæŠ—
                ballState.vel.y -= 9.8 * dt;
                ballState.vel.multiplyScalar(0.995);
                
                // ãƒã‚°ãƒŒã‚¹åŠ¹æœ (å›è»¢ã«ã‚ˆã‚‹æ›²ãŒã‚Š)
                const lift = new THREE.Vector3().crossVectors(ballState.spin, ballState.vel).multiplyScalar(0.015);
                ballState.vel.add(lift);

                ballState.pos.add(ballState.vel.clone().multiplyScalar(dt));

                // è¡çª: å°
                if(ballState.pos.y <= TABLE_H && Math.abs(ballState.pos.x)<TABLE_W/2 && Math.abs(ballState.pos.z)<TABLE_L/2) {
                    if(ballState.vel.y < 0) {
                        playSound('bounce');
                        ballState.pos.y = TABLE_H;
                        ballState.vel.y *= -0.85;
                        // å›è»¢ã«ã‚ˆã‚‹åŠ é€Ÿ/æ¸›é€Ÿ (Kick)
                        ballState.vel.z += ballState.spin.x * 0.05;
                    }
                }
                // è¡çª: åºŠ/ãƒŸã‚¹
                else if(ballState.pos.y < 0) {
                    playSound('miss');
                    scorePoint(ballState.pos.z > 0 ? 2 : 1);
                }

                // è¡çª: ãƒãƒƒãƒˆ
                if(Math.abs(ballState.pos.z)<0.2 && ballState.pos.y < TABLE_H+NET_H && Math.abs(ballState.pos.x)<TABLE_W/2) {
                    ballState.vel.z *= -0.1; ballState.vel.y *= 0.5;
                }

                // è¡çª: ãƒ©ã‚±ãƒƒãƒˆ
                checkHit(players[0], p1Ctrl);
                checkHit(players[1], p2Ctrl);
            }

            ball.position.copy(ballState.pos);
            ball.rotation.x += ballState.spin.x * dt; // å›è»¢ã®è¦‹ãŸç›®
        }

        function checkHit(player, ctrl, isServe=false) {
            if(!ctrl) return;
            const dist = ballState.pos.distanceTo(player.mesh.position);
            
            if(dist < 2.5) {
                if(ctrl.isSwinging || isServe) {
                    if(!isServe && ballState.lastHit === player.id) return; // é€£æ‰“é˜²æ­¢
                    
                    ballState.lastHit = player.id;
                    ballState.active = true;
                    playSound('hit');
                    ctrl.rumble();

                    // æ‰“ã¡è¿”ã—ãƒ™ã‚¯ãƒˆãƒ«è¨ˆç®—
                    const dirZ = player.id===1 ? -1 : 1;
                    const power = Math.max(15, Math.min(30, ctrl.swing * 5));
                    
                    // é€Ÿåº¦æ±ºå®š
                    // ãƒ©ã‚±ãƒƒãƒˆè§’åº¦(tiltY)ã§å¼¾é“ã‚’åˆ¶å¾¡
                    // ä¸Šå‘ã(ãƒã‚¤ãƒŠã‚¹) -> ãƒ«ãƒ¼ãƒ—/ã‚«ãƒƒãƒˆ, ä¸‹å‘ã(ãƒ—ãƒ©ã‚¹) -> ã‚¹ãƒãƒƒã‚·ãƒ¥/ãƒ‰ãƒ©ã‚¤ãƒ–
                    ballState.vel.z = dirZ * power;
                    ballState.vel.y = 5 + (ctrl.tiltY * -10); // è§’åº¦ã§é«˜ã•èª¿æ•´
                    ballState.vel.x = (ballState.pos.x - player.mesh.position.x) * 3; // å·¦å³ã®æ‰“ã¡åˆ†ã‘

                    // å›è»¢ (Spin)
                    // æ‰‹é¦–ã®è§’åº¦ãŒãã®ã¾ã¾å›è»¢ã«ãªã‚‹
                    ballState.spin.x = ctrl.tiltY * 30; // Top/Back spin
                    ballState.spin.y = ctrl.tiltX * -10; // Side spin (ä½“å‹¢ã«ã‚ˆã‚‹)
                }
            }
        }

        function scorePoint(winner) {
            scores[winner-1]++;
            document.getElementById('s-p1').innerText = scores[0];
            document.getElementById('s-p2').innerText = scores[1];
            
            showMsg(winner===1 ? "P1 POINT" : "P2 POINT");
            
            if((scores[0]+scores[1])%2 === 0) server = server===1?2:1;
            
            setTimeout(resetBall, 2000);
        }

        function resetBall() {
            ballState.active = false;
            ballState.lastHit = 0;
            const z = server===1 ? 22 : -22;
            ballState.pos.set(0, 10, z);
            ballState.vel.set(0,0,0);
            ballState.spin.set(0,0,0);
            showMsg(`P${server} SERVE`);
        }

        function showMsg(txt) {
            const el = document.getElementById('msg-overlay');
            el.innerText = txt; el.style.display='block';
            setTimeout(()=>el.style.display='none', 1500);
        }

        function playSound(type) {
            if(actx.state==='suspended') actx.resume();
            const o = actx.createOscillator();
            const g = actx.createGain();
            o.connect(g); g.connect(actx.destination);
            const t = actx.currentTime;
            
            if(type==='hit') {
                o.frequency.setValueAtTime(600, t);
                o.frequency.exponentialRampToValueAtTime(100, t+0.1);
                g.gain.setValueAtTime(0.5, t); g.gain.linearRampToValueAtTime(0, t+0.1);
                o.start(t); o.stop(t+0.1);
            } else if(type==='bounce') {
                o.frequency.setValueAtTime(300, t);
                g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t+0.05);
                o.start(t); o.stop(t+0.05);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            update(0.016);
            renderer.render(scene, camera);
        }

        // --- æ¥ç¶š ---
        let p1Ctrl, p2Ctrl;
        document.getElementById('connect-btn').onclick = async () => {
            const d = await navigator.hid.requestDevice({filters:[{vendorId:0x057e}]});
            if(d.length) {
                const gc = new GyroController(d[0], p1Ctrl?2:1);
                await gc.init();
                if(gc.id===1) p1Ctrl=gc; else p2Ctrl=gc;
                
                if(p1Ctrl && p2Ctrl) {
                    document.getElementById('setup-screen').style.display='none';
                    initGame();
                    isPlaying=true;
                } else {
                    document.getElementById('connect-btn').innerText = "PLAYER 2 ã‚’æ¥ç¶š";
                }
            }
        };
    </script>
</body>
</html>
